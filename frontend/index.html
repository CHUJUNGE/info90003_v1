<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crime Scene Reconstruction</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&family=Audiowide&family=Exo+2:wght@400;700&family=Syncopate:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <!-- Three.js CDN -->
    <script src="js/esp32.js"></script> <!-- ESP32 BLE Connection -->
</head>
<body>
    <div class="container">
        <div class="scene-container">
            <!-- Three.js canvas will be appended here by globe.js -->
            <h1 class="title">Crime Scene Reconstruction Device</h1>
        </div>

        <button id="fullscreen-btn" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
            </svg>
        </button>

        <!-- ESP32 Connection Modal -->
        <div id="esp32-connect-modal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="close-modal-btn">&times;</span>
                <h2>Connect to ESP32</h2>
                <button id="connect-esp32-btn">Connect</button>
                <p id="esp32-modal-status">Status: Idle</p>
            </div>
        </div>

        <!-- ESP32 Connection Status Indicator (Bottom Left) -->
        <div id="esp32-status-indicator">
            <span>ESP32: </span><span id="esp32-status-text">Disconnected</span>
        </div>

        <!-- Stage Elements Container -->
        <div id="stage-elements-container">
            <!-- Stage 5: Loading/Conclusion Screen -->
            <div id="stage5-loading-container" class="stage-message" style="display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center;">
                <div class="loader"></div>
                <p id="stage5-message" style="margin-top: 20px; font-size: 1.5em; color: #fff;">正在分析所有证物...</p>
            </div>

            <!-- Stage 0 elements (like the globe canvas) are already here or dynamically added -->
            <div id="stage1-welcome-message" class="stage-message" style="display: none;">Welcome</div>
            <!-- Stage 2 elements -->
            <div id="stage2-container" class="stage-container" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                <h2 id="stage2-title" class="stage-title" style="opacity: 0; transition: opacity 1s ease-in;">Case 001: A woman was found dead in her home</h2>
                <div style="position: relative; width: 100%; height: 100%; overflow: hidden;">
                    <canvas id="floorplan-canvas" style="width: 100%; height: 100%; position: relative; left: -15%;"></canvas>
                </div>
                
                <!-- Scan instruction image and text -->
                <div id="scan-instruction" style="position: absolute; right: 30px; bottom: 30px; text-align: center; opacity: 0; transition: opacity 1s ease-in;">
                    <img src="assets/picture/scan_instructor.png" alt="Scan Instructor" style="max-width: 300px; display: block; margin: 0 auto;">
                    <p class="scan-text">Scan the evidence to uncover the truth</p>
                </div>
            </div>
            <!-- Stage 3-1: RFID Scan Result for Cup -->
            <div id="stage3-1-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <video id="rfid-scan-video">
                    <source src="assets/videos/cup_scan.mp4" type="video/mp4">
                    您的浏览器不支持HTML5视频。
                </video>
                <p id="rfid-scan-message" style="font-size: 1.8em; color: #00ff00; text-shadow: 0 0 7px #00ff00, 0 0 10px #00ff00;"></p>
                <img id="wife-image" src="assets/picture/wife.png" alt="Wife's Picture" style="display: none;">
            </div>
            <!-- Stage 3-2: Knife Scan Video -->
            <div id="stage3-2-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <video id="knife-scan-video">
                    <!-- JavaScript会设置src -->
                </video>
                <img id="robot-image-stage3-2" src="assets/picture/robot.png" alt="Robot Image" style="display: none;">
            </div>
            <!-- Stage 4-1: Cup Movement Video -->
            <div id="stage4-1-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <div style="position: relative; width: 70%; max-width: 800px;">
                    <video id="cup-movement-video" width="100%" height="auto" style="margin-bottom: 20px; border: 2px solid #00ff00;" loop>
                        <source src="assets/videos/cup_movement.mp4" type="video/mp4">
                        您的浏览器不支持HTML5视频。
                    </video>
                    <div id="countdown-timer" style="position: absolute; top: 10px; right: 10px; font-size: 2.5em; color: #00ccff; font-weight: bold; text-shadow: 0 0 8px #0066ff; font-family: Arial, sans-serif; letter-spacing: 0px; display: none; border: 1px solid #00ccff; border-radius: 5px; padding: 2px 10px; background-color: rgba(0,10,20,0.7);">6</div>
                </div>
                <p id="cup-movement-message" style="font-size: 0.4em; color: #0091ff; text-shadow: 0 0 2px #00ccff;">Please try to perform the action to verify the action logic</p>
            </div>
            <!-- Stage 4-1-1: Action Reproduction Prompt -->
            <div id="stage4-1-1-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; height: 100%;">
                <p id="action-reproduction-message">Please reproduce the action</p>
            </div>

            <!-- Stage 4-2: Knife Movement Video -->
            <div id="stage4-2-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <div style="position: relative; width: 70%; max-width: 800px;">
                    <video id="knife-movement-video" width="100%" height="auto" style="margin-bottom: 20px; border: 2px solid #00ff00;" loop>
                        <source src="assets/videos/knife_movement.mp4" type="video/mp4">
                        您的浏览器不支持HTML5视频。
                    </video>
                    <div id="countdown-timer-stage4-2" style="position: absolute; top: 10px; right: 10px; font-size: 2.5em; color: #00ccff; font-weight: bold; text-shadow: 0 0 8px #0066ff; font-family: Arial, sans-serif; letter-spacing: 0px; display: none; border: 1px solid #00ccff; border-radius: 5px; padding: 2px 10px; background-color: rgba(0,10,20,0.7);">6</div>
                </div>
                <p id="knife-movement-message" style="font-size: 0.4em; color: #0091ff; text-shadow: 0 0 2px #00ccff;">Please try to perform the action to verify the action logic</p>
            </div>

            <!-- Stage 4-2-1: Action Reproduction Prompt (Knife) -->
            <div id="stage4-2-1-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; height: 100%;">
                <p id="action-reproduction-message-stage4-2-1">Please reproduce the action with the knife</p>
            </div>

            <!-- Stage 3-3: Phone Scan -->
            <div id="stage3-3-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <video id="phone-scan-video" playsinline muted preload="auto"></video>
                <img id="husband-image" src="assets/picture/husband.png" alt="Husband Image" style="display: none;" class="glitch-image-effect">
                <!-- Optional: Message during phone scan -->
                <!-- <p id="phone-scan-message">Scanning Phone...</p> -->
            </div>

            <!-- Stage 4-3: Phone Movement Video -->
            <div id="stage4-3-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <div style="position: relative; width: 70%; max-width: 800px;">
                    <video id="phone-movement-video" width="100%" height="auto" style="margin-bottom: 20px; border: 2px solid #00ff00;" playsinline muted loop preload="auto"></video>
                    <div id="countdown-timer-stage4-3" style="position: absolute; top: 10px; right: 10px; font-size: 2.5em; color: #00ccff; font-weight: bold; text-shadow: 0 0 8px #0066ff; font-family: Arial, sans-serif; letter-spacing: 0px; display: none; border: 1px solid #00ccff; border-radius: 5px; padding: 2px 10px; background-color: rgba(0,10,20,0.7);"></div>
                </div>
                <p id="phone-movement-message" style="font-size: 0.4em; color: #0091ff; text-shadow: 0 0 2px #00ccff;">Please try to perform the action to verify the action logic</p>
            </div>

            <!-- Stage 4-3-1: Action Reproduction Prompt (Phone) -->
            <div id="stage4-3-1-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; height: 100%;">
                <p id="action-reproduction-message-stage4-3-1">Please reproduce the action</p>
            </div>

            <!-- Stage 3-4: Monitor Scan (Mirrors Stage 3-1 for Cup) -->
            <div id="stage3-4-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <video id="monitor-scan-video" src="assets/videos/camera_scan.mp4" playsinline muted preload="auto"></video>
                <img id="monitor-scene-image" src="assets/picture/monitor.png" alt="Monitor Scene Image" style="display: none;" class="glitch-image-effect">
                <p id="monitor-scan-message" class="scan-message-overlay"></p> <!-- Optional message -->
            </div>

            <!-- Stage 4-4: Monitor Movement Video (Mirrors Stage 4-1 for Cup) -->
            <div id="stage4-4-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                <div style="position: relative; width: 70%; max-width: 800px;">
                    <video id="monitor-movement-video" src="assets/videos/camera_movement.mp4" width="100%" height="auto" style="margin-bottom: 20px; border: 2px solid #00ff00;" playsinline muted loop preload="auto"></video>
                    <div id="countdown-timer-stage4-4" style="position: absolute; top: 10px; right: 10px; font-size: 2.5em; color: #00ccff; font-weight: bold; text-shadow: 0 0 8px #0066ff; font-family: Arial, sans-serif; letter-spacing: 0px; display: none; border: 1px solid #00ccff; border-radius: 5px; padding: 2px 10px; background-color: rgba(0,10,20,0.7);"></div>
                </div>
                <p id="monitor-movement-message" style="font-size: 0.4em; color: #0091ff; text-shadow: 0 0 2px #00ccff;">Please try to perform the action to verify the action logic</p>
            </div>

            <!-- Stage 4-4-1: Action Reproduction Prompt (Monitor) (Mirrors Stage 4-1-1 for Cup) -->
            <div id="stage4-4-1-container" class="stage-message" style="display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; height: 100%;">
                <p id="action-reproduction-message-stage4-4-1">Please reproduce the action</p>
            </div>
        </div>

        <!-- Audio element for stage-specific sounds -->
        <audio id="stage-audio" loop preload="auto"></audio>

        <!-- Scripts -->
        <script type="module" src="js/globe.js"></script>
        <script src="js/esp32.js"></script> <!-- Ensure this is included -->
        <script src="js/AudioManager.js"></script> <!-- Include AudioManager -->
        <script src="js/3d-floorplan.js"></script> <!-- Include 3D Floorplan -->
        <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script> <!-- Socket.IO Client for RFID -->
        <script type="module"> 
            let audioManager; 
            let isTransitioningToStage1 = false; // Flag to prevent multiple transitions
            let currentStage = 'stage0'; // Initialize current application stage
            const TAG_NAMES = { cup: 'cup', knife: 'knife', phone: 'phone', monitor: 'monitor' }; // Define tag names for consistency
            let scannedTags = new Set(); // Set to store EPCs of already processed tags
            let currentEPC = null; // To store the EPC of the tag currently being processed through a multi-stage flow

            function hideAllStages() {
                const selectors = [
                    '.initial-container', // For Stage 0
                    '.stage-container',   // For Stage 1, Stage 2, etc.
                    '.stage-message'      // For sub-stages like 3-1, 4-1, prompts
                ];
                const stageElements = document.querySelectorAll(selectors.join(', '));

                stageElements.forEach(element => {
                    if (!element.closest('#esp32-connect-modal') && element.id !== 'esp32-connect-modal') {
                        if (element.id !== 'main-content-wrapper') {
                            element.style.display = 'none';
                            element.style.opacity = '0';
                        }
                    }
                });

                const titleElement = document.querySelector('.title');
                if (titleElement) titleElement.style.display = 'none';

                const instructionsStage0 = document.getElementById('instructions-stage0');
                if (instructionsStage0) instructionsStage0.style.display = 'none';
                
                const globeContainer = document.getElementById('globe-container');
                if (globeContainer) globeContainer.style.display = 'none';
                
                // const statusDisplay = document.getElementById('esp32-status-display'); 
                // if (statusDisplay && statusDisplay.classList.contains('visible-in-stage0')) {
                //     // statusDisplay.style.display = 'none'; 
                // }

                console.log('hideAllStages: All stage visual elements hidden.');
            }


            document.addEventListener('DOMContentLoaded', () => {
                const modal = document.getElementById('esp32-connect-modal');
                const closeModalBtn = document.getElementById('close-modal-btn');
                const connectEsp32Btn = document.getElementById('connect-esp32-btn');
                const esp32IpInput = document.getElementById('esp32-ip');
                const modalStatus = document.getElementById('esp32-modal-status');
                const statusIndicator = document.getElementById('esp32-status-indicator');
                const statusText = document.getElementById('esp32-status-text');

                let esp32Connection = null;
            let rfidSocket = null; // Socket.IO connection for RFID backend 

                // Initialize AudioManager - assign to the higher-scoped variable
                audioManager = new AudioManager(); 
                audioManager.loadSound('stage0Music', 'assets/audio/stage0.wav', true);
                // Preload Stage 1 sounds
                audioManager.loadSound('stage1WelcomeSFX', 'assets/audio/stage1_welcome_sfx.wav', false);
                audioManager.loadSound('stage1WelcomeVoiceZH', 'assets/audio/stage1_welcome_voice_zh.mp3', false);
                audioManager.loadSound('scanningSFX', 'assets/audio/scanning.wav', false);
                audioManager.loadSound('knifeScanAudio', 'assets/audio/knife_scan.mp3', false); // <-- 新增：加载刀具扫描音效
                audioManager.loadSound('cupScanAudio', 'assets/audio/cup_scan.mp3', false);
                audioManager.loadSound('victimBioAudio', 'assets/audio/victim_biological.mp3', false);
                audioManager.loadSound('cupMovementAudio', 'assets/audio/cup_scan.mp3', false); // 复用 cup_scan.mp3 作为 cup_movement.mp4 的音频
                audioManager.loadSound('countdownBeeping', 'assets/audio/countdown_beeping.wav', false);
                audioManager.loadSound('fibreTraceAudio', 'assets/audio/fibre_trace.mp3', false); // <-- 新增：加载机器人图片音效
                audioManager.loadSound('phoneScanAudio', 'assets/audio/phone_scan.mp3', false);
                audioManager.loadSound('phoneContactAudio', 'assets/audio/phone_contact.mp3', false);
                audioManager.loadSound('monitorScanVoice', 'assets/audio/camera_scan.mp3', false);
                audioManager.loadSound('monitorSceneVoice', 'assets/audio/surveillance_camera.mp3', false);

                // Attempt to play Stage 0 music. If audio not unlocked, it will be queued and play on first interaction.
                if (audioManager) { 
                    console.log('DOMContentLoaded: audioManager instance available, setting stage0Music.');
                    audioManager.setStageMusic('stage0Music'); 
                } else {
                    console.error('DOMContentLoaded: audioManager is NOT available here!');
                }

                const titleElement = document.querySelector('.title'); 
                const stage1WelcomeMessage = document.getElementById('stage1-welcome-message'); // Get Stage 1 Welcome message

                // Make Stage 0 elements visible
                if (titleElement) {
                    titleElement.classList.add('flicker-effect'); 
                }

                // ESP32 BLE Connection Setup
                // 使用已经声明的变量，避免重复声明
                // modal -> esp32ConnectModal
                // modalStatus -> esp32ModalStatus
                // statusText -> esp32StatusText

                // 检查ESP32BLEConnection类是否可用（来自js/esp32.js）
                if (typeof ESP32BLEConnection === 'undefined') {
                    console.error('ESP32BLEConnection类未加载。请检查脚本引用。');
                    if (modalStatus) modalStatus.textContent = '错误：BLE脚本未加载。';
                    // 如果类未加载，禁用连接按钮
                    if (connectEsp32Btn) connectEsp32Btn.disabled = true;
                } else {
                    // 创建ESP32BLE连接对象
                    esp32Connection = new ESP32BLEConnection();

                    // 使用原有的updateUI函数，但修改变量引用
                    function updateUI(state, message = '') {
                        statusIndicator.classList.add('visible');
                        switch (state) {
                            case 'connecting':
                                modalStatus.textContent = `状态：正在连接... ${message}`;
                                statusText.textContent = '正在连接...';
                                statusText.className = 'connecting';
                                connectEsp32Btn.disabled = true;
                                connectEsp32Btn.textContent = '正在连接...';
                                break;
                            case 'connected':
                                modalStatus.textContent = `状态：已连接！`;
                                statusText.textContent = '已连接';
                                statusText.className = 'connected';
                                connectEsp32Btn.disabled = false;
                                connectEsp32Btn.textContent = '断开连接'; 
                                modal.style.display = 'none'; 
                                break;
                            case 'disconnected':
                                modalStatus.textContent = `状态：已断开连接。${message}`;
                                statusText.textContent = '已断开连接';
                                statusText.className = 'disconnected';
                                connectEsp32Btn.disabled = false;
                                connectEsp32Btn.textContent = '连接';
                                break;
                            case 'error':
                                modalStatus.textContent = `状态：错误。${message}`;
                                statusText.textContent = '错误';
                                statusText.className = 'disconnected'; 
                                connectEsp32Btn.disabled = false;
                                connectEsp32Btn.textContent = '连接';
                                break;
                            default: 
                                modalStatus.textContent = '状态：空闲。按空格键切换。';
                                statusText.textContent = '已断开连接';
                                statusText.className = 'disconnected';
                                statusIndicator.classList.remove('visible'); 
                        }
                    }

                    // 设置连接成功回调 - 使用正确的方法注册回调
                    esp32Connection.onConnect(function() {
                        console.log('ESP32 BLE已连接');
                        updateUI('connected');
                        // 如果当前是stage0，设置LED为蓝色常亮
                        if (currentStage === 'stage0') {
                            esp32Connection.setLedMode(2); // 2对应蓝色常亮
                            console.log('已发送命令到ESP32：设置LED为蓝色常亮（stage0）');
                        }
                    });

                    // 设置断开连接回调 - 使用正确的方法注册回调
                    esp32Connection.onDisconnect(function(reason) {
                        console.log('ESP32 BLE已断开连接', reason ? '原因: ' + reason : '');
                        updateUI('disconnected');
                    });

                    // 设置数据接收回调 - 使用正确的方法注册回调
                    esp32Connection.onData(function(data) {
                        console.log('从ESP32接收到数据:', data);
                        
                        // 处理KEY1命令，模拟键盘按下"1"键
                        if (data.type === 'mpu_string' && data.payload === 'KEY1') {
                            console.log('收到KEY1命令，模拟键盘按下1键');
                            // 直接调用转换到Stage1的逻辑，而不是模拟键盘事件
                            if (!isTransitioningToStage1) {
                                isTransitioningToStage1 = true;
                                console.log('ESP32按钮触发: 转换到Stage 1');
                                
                                const titleElement = document.querySelector('.title'); 
                                const stage1WelcomeMessage = document.getElementById('stage1-welcome-message');
                                
                                // 1. 停止Stage 0音乐并开始Stage 0元素消失
                                if (audioManager) {
                                    audioManager.setStageMusic(null); // 停止stage 0音乐
                                }
                                
                                if (titleElement) {
                                    titleElement.classList.remove('flicker-effect'); 
                                    titleElement.style.opacity = '0';
                                    titleElement.style.pointerEvents = 'none';
                                }
                                
                                if (window.currentGlobe && typeof window.currentGlobe.dissipate === 'function') {
                                    window.currentGlobe.dissipate(); // 开始地球消散
                                }
                                
                                // 2. 播放转场音效
                                if (audioManager) {
                                    audioManager.playSound('stage1WelcomeSFX');
                                }
                                
                                // 3. 延迟显示Stage 1欢迎信息
                                if (stage1WelcomeMessage) {
                                    stage1WelcomeMessage.style.display = 'block';
                                    
                                    setTimeout(() => {
                                        requestAnimationFrame(() => {
                                            stage1WelcomeMessage.style.opacity = '1';
                                            stage1WelcomeMessage.style.pointerEvents = 'auto';
                                        });
                                        
                                        stage1WelcomeMessage.addEventListener('transitionend', function onTransitionEnd() {
                                            currentStage = 'stage1';
                                            console.log('Stage 1现在激活. currentStage:', currentStage);
                                            
                                            if (audioManager) {
                                                audioManager.playSound('stage1WelcomeSFX');
                                                
                                                // 发送蓝光流动效果命令 (模式5)
                                                if (esp32Connection && esp32Connection.isConnected()) {
                                                    esp32Connection.sendCommand('L5');
                                                    console.log('发送蓝光流动效果命令: L5');
                                                    
                                                    // 发送马达震动命令 (M = 单次震动)
                                                    setTimeout(() => {
                                                        esp32Connection.sendCommand('M');
                                                        console.log('发送单次马达震动命令: M');
                                                    }, 500);
                                                } else {
                                                    console.warn('ESP32未连接，无法发送蓝光流动和马达震动命令');
                                                }
                                                
                                                setTimeout(() => {
                                                    audioManager.playSound('stage1WelcomeVoiceZH');
                                                    
                                                    const stage1WelcomeVoice = audioManager.sounds['stage1WelcomeVoiceZH'].element;
                                                    stage1WelcomeVoice.addEventListener('ended', function onVoiceEnded() {
                                                        console.log('Stage 1欢迎语音结束，等待3秒后转换到Stage 2');
                                                        
                                                        setTimeout(() => {
                                                            // 直接转换到Stage 2，不发送L0命令
                                                            transitionToStage2();
                                                        }, 3000);
                                                        
                                                        stage1WelcomeVoice.removeEventListener('ended', onVoiceEnded);
                                                    }, { once: true });
                                                }, 1000);
                                            }
                                            
                                            stage1WelcomeMessage.removeEventListener('transitionend', onTransitionEnd);
                                        }, { once: true });
                                    }, 1000);
                                }
                            }
                        }
                        // 处理其他MPU数据
                    });

                    // Show modal by default
                    modal.style.display = 'block';
                    updateUI('idle');

                    // 使用已有的事件处理程序
                    // closeModalBtn.onclick已在前面定义

                    window.onclick = (event) => {
                        if (event.target == modal) {
                            // esp32ConnectModal.style.display = 'none'; 
                        }
                    }

                    // 使用已有的keydown事件处理程序，但修改检查条件
                    document.addEventListener('keydown', (event) => {
                        if (event.code === 'Space') {
                            event.preventDefault(); 
                            if (modal.style.display === 'block') {
                                modal.style.display = 'none';
                            } else {
                                modal.style.display = 'block';
                            }
                            // Update status in modal if shown
                            if (esp32Connection && esp32Connection.isConnected()) {
                                updateUI('connected');
                            } else if (connectEsp32Btn.disabled) { 
                                updateUI('connecting', modalStatus.textContent.replace('状态：', ''));
                            } else {
                                updateUI('disconnected', modalStatus.textContent.replace('状态：', ''));
                            }
                        }
                    });

                    // 替换原有的点击事件处理程序
                    // 移除之前的事件监听器
                    const newConnectBtn = connectEsp32Btn.cloneNode(true);
                    connectEsp32Btn.parentNode.replaceChild(newConnectBtn, connectEsp32Btn);
                    const connectEsp32BtnNew = document.getElementById('connect-esp32-btn');
                    
                    connectEsp32BtnNew.addEventListener('click', async () => {
                        if (esp32Connection.isConnected()) {
                            esp32Connection.disconnect();
                        } else {
                            try {
                                updateUI('connecting');
                                console.log('正在尝试通过BLE连接到ESP32...');
                                await esp32Connection.connect();
                                // onConnect回调将处理状态更新
                            } catch (error) {
                                console.error('BLE连接失败:', error);
                                updateUI('error', error.message || '连接失败');
                            }
                        }
                    });
                }

                // Listen for key presses for stage transitions
                document.addEventListener('keyup', (event) => {
                    const titleElement = document.querySelector('.title'); 
                    const stage1WelcomeMessage = document.getElementById('stage1-welcome-message');

                    if (event.key === '1' && !isTransitioningToStage1) { // Check the flag here
                        isTransitioningToStage1 = true; // Set the flag
                        console.log('Key 1 pressed: Transitioning to Stage 1 (flag set)');
                        console.log('Keyup event: Checking audioManager instance:', audioManager);
                        
                        // 1. Stop Stage 0 music & Start Stage 0 elements disappearing
                        if (audioManager) {
                            console.log('Keyup event: audioManager is available, attempting to stop music and play SFX.');
                            audioManager.setStageMusic(null); // Stop stage 0 music
                        } else {
                            console.error('Keyup event: audioManager is NOT available here! Cannot stop music or play SFX.');
                        }
                        
                        if (titleElement) {
                            titleElement.classList.remove('flicker-effect'); 
                            titleElement.style.opacity = '0';
                            titleElement.style.pointerEvents = 'none';
                        }

                        if (window.currentGlobe && typeof window.currentGlobe.dissipate === 'function') {
                            window.currentGlobe.dissipate(); // Start globe dissipation
                        }

                        // 2. Play transition SFX
                        if (audioManager) { // Check again for playing SFX
                            audioManager.playSound('stage1WelcomeSFX');
                        }

                        // 3. Delayed fade-in for Stage 1 Welcome message
                        if (stage1WelcomeMessage) {
                            // Ensure it's ready for transition (display block, opacity 0)
                            stage1WelcomeMessage.style.display = 'block'; // Or 'flex' etc. depending on desired layout. It uses .stage-message class with opacity 0.
                            // Add flicker effect if desired for stage 1 welcome, otherwise skip.
                            // stage1WelcomeMessage.classList.add('flicker-effect'); 
                            
                            // Delay the fade-in to allow SFX to play or Stage 0 elements to disappear
                            setTimeout(() => {
                                requestAnimationFrame(() => { // Ensure display change is processed before opacity transition
                                    stage1WelcomeMessage.style.opacity = '1';
                                    stage1WelcomeMessage.style.pointerEvents = 'auto';
                                });

                                // 4. Play welcome voice after Stage 1 Welcome message transition ends
                                stage1WelcomeMessage.addEventListener('transitionend', function onTransitionEnd() {
                                    currentStage = 'stage1'; // Set current stage now that Stage 1 is active
                                    console.log('Stage 1 is now active. currentStage:', currentStage);
                                    if (audioManager) { // Check again for playing voice
                                        audioManager.playSound('stage1WelcomeVoiceZH');
                                        
                                        // Add event listener for when the welcome voice ends
                                        const stage1WelcomeVoice = audioManager.sounds['stage1WelcomeVoiceZH'].element;
                                        stage1WelcomeVoice.addEventListener('ended', function onVoiceEnded() {
                                            console.log('Stage 1 welcome voice ended, waiting 3s before transitioning to Stage 2');
                                            
                                            // Wait 3 seconds before transitioning to Stage 2
                                            setTimeout(() => {
                                                transitionToStage2();
                                            }, 3000);
                                            
                                            // Remove the event listener to prevent memory leaks
                                            stage1WelcomeVoice.removeEventListener('ended', onVoiceEnded);
                                        }, { once: true });
                                    }
                                    // Optional: Play Stage 1 music here
                                    // if (window.audioManager) {
                                    //     window.audioManager.setStageMusic('stage1Music'); // Assuming 'stage1Music' is loaded
                                    // }
                                    stage1WelcomeMessage.removeEventListener('transitionend', onTransitionEnd); // Clean up listener
                                }, { once: true }); // Ensure listener fires only once

                            }, 1000); // Adjust delay (in ms) as needed. E.g., 1000ms = 1 second
                        }
                    } else if (event.key === '1' && isTransitioningToStage1) {
                        console.log('Key 1 pressed, but already transitioning to Stage 1. Ignoring.');
                    }
                    // Add other stage transitions here (e.g., else if (event.key === '2'))
                });

                function initializeRfidConnection() {
                    if (rfidSocket && rfidSocket.connected) {
                        console.log('RFID connection already initialized and connected.');
                        // If already connected, ensure scanning is (re)started if appropriate for current stage
                        if (currentStage === 'stage2') { // Or other relevant stages
                            console.log('Requesting backend to START RFID scan (already connected).');
                            rfidSocket.emit('start_rfid_scan');
                        }
                        return; 
                    }

                    console.log('Initializing RFID connection for Stage 2 onwards...');
                    rfidSocket = io(); 

                    rfidSocket.on('connect', () => {
                        console.log('Connected to RFID backend server (main_server.py) - Stage 2 onwards.');
                        console.log('Requesting backend to START RFID scan (on connect).');
                        rfidSocket.emit('start_rfid_scan');
                    });

                    rfidSocket.on('disconnect', () => {
                        console.log('Disconnected from RFID backend server.');
                    });

                    rfidSocket.on('rfid_data', (data) => {
                        console.log('RFID data received from backend:', data); // Keep this log as the first line inside handler

                        const epc = data.epc; // 修改：从 data.tag_id 改为 data.epc
                        const itemName = data.name;

                        if (epc && scannedTags.has(epc)) {
                            console.log(`Tag ${epc} (${itemName || 'Unknown'}) already processed. Ignoring.`);
                            // Optional: Provide user feedback (e.g., a short message on screen)
                            if (rfidSocket && rfidSocket.connected && currentStage === 'stage2') {
                                // Ensure scanning continues if it stopped implicitly
                                console.log('Requesting backend to RESTART RFID scan for already known tag while in stage2.');
                                rfidSocket.emit('start_rfid_scan');
                            }
                            return; // Stop further processing for this already scanned tag
                        }
                        
                        // If it's a new tag and is the 'cup' (which has a multi-stage flow), store its EPC.
                        // It will be added to scannedTags upon completion of its flow (in transitionToStage4_1_1).
                        if (epc && itemName === 'cup') {
                            currentEPC = epc;
                            console.log('Cup detected, currentEPC set to:', currentEPC, '(EPC was:', epc, ')'); // 新增日志
                        } else if (epc && itemName && itemName !== 'cup' && itemName !== 'knife') { // Exclude cup and knife as they have specific EPC handling
                            // For other named items that might have a simpler, direct processing (no multi-stage flow ending in 4-1-1)
                            // and are considered 'done' immediately, add them to scannedTags here.
                            // This part is illustrative; adapt if other items have different flows.
                            // scannedTags.add(epc);
                            // console.log(`Tag ${epc} (${itemName}) processed and recorded (simple flow).`);
                        }

                        // Original logic for specific items like 'cup' will follow this block.
                        console.log('Checking for cup: currentStage is', currentStage, 'data.name is', data.name); 
                        if (data.name === 'cup' && currentStage === 'stage2') { 
                            console.log('"Cup" tag detected! Transitioning to Stage 3-1.');
                            if (rfidSocket && rfidSocket.connected) {
                               rfidSocket.emit('stop_rfid_scan'); 
                            }
                            const rfidScanMessageEl = document.getElementById('rfid-scan-message');
                            if (rfidScanMessageEl && data.message_en) {
                                rfidScanMessageEl.textContent = data.message_en;
                            }
                            audioManager.playSound('scanningSFX');
                            transitionToStage3_1();
                        } else if (data.name === 'knife' && currentStage === 'stage2') {
                            console.log('"Knife" tag detected! Transitioning to Stage 3-2.');
                            if (rfidSocket && rfidSocket.connected) {
                                rfidSocket.emit('stop_rfid_scan'); 
                            }
                            // For one-off items like knife, if its EPC shouldn't allow re-scan immediately,
                            // set currentEPC here. It will be added to scannedTags in transitionToStage3_2.
                            if (epc) { // epc comes from data.epc now
                                currentEPC = epc; 
                            }
                            transitionToStage3_2();
                        } else if (data.name === 'phone' && currentStage === 'stage2') {
                            console.log('\"Phone\" tag detected! Transitioning to Stage 3-3.');
                            if (rfidSocket && rfidSocket.connected) {
                                rfidSocket.emit('stop_rfid_scan'); 
                                console.log('Requested backend to STOP RFID scan for Phone.');
                            }
                            if (epc) { // epc comes from data.epc
                                currentEPC = epc; 
                                console.log('Phone detected, currentEPC set to:', currentEPC);
                            }
                            transitionToStage3_3();
                        } else if (data.name === 'monitor' && currentStage === 'stage2') {
                            console.log('"Monitor" tag detected! Transitioning to Stage 3-4.');
                            // logToBackend('"Monitor" tag detected by frontend.');
                            if (rfidSocket && rfidSocket.connected) {
                                rfidSocket.emit('stop_rfid_scan');
                                console.log('Requested backend to STOP RFID scan for Monitor.');
                                // logToBackend('Frontend requested backend to STOP RFID scan for Monitor.');
                            }
                            if (epc) { // epc comes from data.epc (defined earlier in the handler)
                                currentEPC = epc;
                                console.log('Monitor detected, currentEPC set to:', currentEPC);
                                const monitorScanMessageEl = document.getElementById('monitor-scan-message');
                                if (monitorScanMessageEl) {
                                   monitorScanMessageEl.textContent = `证物-${currentEPC}正在被扫描...`; // Set scan message
                                }
                            }
                            transitionToStage3_4();
                        } else if (data.epc) { // Changed from data.tag_id to data.epc for general case
                            console.log('Another tag detected:', data.tag_id);
                        } else if (data.message === "No tag found"){
                            console.log('Backend reports: No tag found in this scan attempt.');
                        }
                    });

                    rfidSocket.on('rfid_error', (error) => {
                        console.error('RFID Error from backend:', error.message);
                    });

                    rfidSocket.on('rfid_scan_stopped', (data) => {
                        console.log('RFID scanning has been stopped by the backend.', data ? data.message : '');
                    });
                }
                
                // Function to transition from Stage 1 to Stage 2
                function transitionToStage2() {
                    console.log('Transitioning to Stage 2. Called from: ' + currentStage);
                    const stageToHideId_from_currentStage_logic = currentStage; // Save for logging or specific logic

                    let stageToHideElement = null;
                    if (stageToHideId_from_currentStage_logic === 'stage1') {
                        stageToHideElement = document.getElementById('stage1-welcome-message');
                    } else if (stageToHideId_from_currentStage_logic === 'stage4-1-1') {
                        stageToHideElement = document.getElementById('stage4-1-1-container');
                    } else if (currentStage !== 'stage0' && currentStage !== 'stage2') { // General case for other stages
                        stageToHideElement = document.getElementById(currentStage + '-container') || document.getElementById(currentStage);
                    }

                    currentStage = 'stage2'; // Set the new current stage

                    // 发送红色常亮命令 (模式1)
                    if (esp32Connection && esp32Connection.isConnected()) {
                        esp32Connection.sendCommand('L1');
                        console.log('发送红色常亮命令: L1');
                    } else {
                        console.warn('ESP32未连接，无法发送红色常亮命令');
                    }

                    const stage2Container = document.getElementById('stage2-container');
                    const stage2Title = document.getElementById('stage2-title');

                    const setupAndShowStage2 = () => {
                        if (stage2Container) {
                            stage2Container.style.display = 'block'; 
                            stage2Container.style.opacity = '0'; 

                            if (window.floorplanRenderer && typeof window.floorplanRenderer.stopAnimation === 'function') {
                                window.floorplanRenderer.stopAnimation();
                            }
                            if (!window.floorplanRenderer || stageToHideId_from_currentStage_logic === 'stage4-1-1') { 
                                if (window.floorplanRenderer && typeof window.floorplanRenderer.dispose === 'function') {
                                    window.floorplanRenderer.dispose(); 
                                }
                                const floorplanRenderer = new FloorplanRenderer3D('floorplan-canvas');
                                floorplanRenderer.init();
                                floorplanRenderer.createFloorplan();
                                floorplanRenderer.createFloor();
                                floorplanRenderer.createWalls();
                                floorplanRenderer.createFurniture();
                                floorplanRenderer.createDecorations();
                                floorplanRenderer.createEvidenceMarkers();
                                window.floorplanRenderer = floorplanRenderer;
                            }
                            window.floorplanRenderer.startAnimation(); 
                            window.floorplanRenderer.show(); 

                            requestAnimationFrame(() => { 
                                stage2Container.style.opacity = '1';
                                if (stage2Title) stage2Title.style.opacity = '1';
                                
                                setTimeout(() => { 
                                    const scanInstruction = document.getElementById('scan-instruction');
                                    if (scanInstruction) scanInstruction.style.opacity = '1';
                                }, 1000);
                            });
                            
                            audioManager.setStageMusic(null); 
                            initializeRfidConnection(); 
                        } else {
                            console.error('Stage 2 container not found!');
                        }
                    };

                    if (stageToHideElement && stageToHideElement.style.display !== 'none') {
                        console.log('Fading out previous stage element:', stageToHideElement.id);
                        stageToHideElement.style.opacity = '0';
                        stageToHideElement.addEventListener('transitionend', function onHide() {
                            stageToHideElement.style.display = 'none';
                            stageToHideElement.removeEventListener('transitionend', onHide);
                            setupAndShowStage2();
                        }, { once: true });
                    } else {
                        if (stageToHideElement) console.log('Previous stage element (' + stageToHideElement.id + ') not found or already hidden.');
                        else console.log('No specific previous stage element to hide or already in stage 0/2.');
                        setupAndShowStage2();
                    }
                }

                // The DOMContentLoaded listener's closing }); might be targeted if replacing the whole block
                // For now, this replaces just the function definition. Ensure the old function's closing '}' is part of targetContent if replacing the whole block.
                // The original function ended at line 456. The target should be the function definition itself.


                // Function to transition to Stage 5 (Loading/Conclusion)
            function transitionToStage5() {
                console.log('Transitioning to Stage 5: All items scanned, loading conclusion.');
                hideAllStages();
                currentStage = 'stage5';
                const stage5Container = document.getElementById('stage5-loading-container');
                const stage5Message = document.getElementById('stage5-message');
                if (stage5Container) {
                    stage5Container.style.display = 'flex';
                    requestAnimationFrame(() => {
                        stage5Container.style.opacity = '1';
                        if (stage5Message) stage5Message.textContent = '正在分析所有证物...'; // Or any appropriate message
                        // You might want to play a specific sound or start an animation here
                        // For now, it just shows the loading spinner and message.
                        // After a delay, you could transition to a final results screen or loop back.
                        // Example: setTimeout(() => { console.log('Stage 5 finished.'); transitionToStage0(); }, 10000); 
                    });
                } else {
                    console.error('Stage 5 container not found!');
                    transitionToStage2(); // Fallback if Stage 5 is broken
                }
            }

            // Helper function to mark a tag as completed on the server
            async function markTagAsCompletedOnServer(tagName) {
                console.log(`Attempting to mark tag '${tagName}' as completed on server.`);
                try {
                    const response = await fetch('/mark_tag_completed', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ tag_name: tagName }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error(`Error marking tag '${tagName}' completed:`, response.status, errorData);
                        return { all_completed: false, error: true }; // Indicate error and not all completed
                    }
                    const result = await response.json();
                    console.log(`Tag '${tagName}' marked. Server response:`, result);
                    return { all_completed: result.all_completed, error: false };
                } catch (error) {
                    console.error(`Network or other error marking tag '${tagName}':`, error);
                    return { all_completed: false, error: true }; // Indicate error and not all completed
                }
            }

            // Function to transition to Stage 3-1 (Cup Scan)

                // Function to transition to Stage 3-2 (Knife Scan)
                function transitionToStage3_2() {
                    console.log('Transitioning to Stage 3-2 for Knife Scan');
                    const stage2Container = document.getElementById('stage2-container');
                    const stage3_2Container = document.getElementById('stage3-2-container');
                    const knifeScanVideo = document.getElementById('knife-scan-video');

                    // 发送红色流动光和持续马达震动命令
                    if (esp32Connection && esp32Connection.isConnected()) {
                        esp32Connection.sendCommand('L4'); // 红色流动光 (L4是红色流动)
                        console.log('发送红色流动光命令: L4 (Stage 3-2)');
                        
                        // 添加200ms延迟再发送马达命令
                        setTimeout(() => {
                            esp32Connection.sendCommand('M4'); // 持续马达震动 (M4 = 持续震动)
                            console.log('发送持续马达震动命令: M4 (Stage 3-2)');
                        }, 200);
                    } else {
                        console.warn('ESP32未连接，无法发送红色流动光和马达震动命令 (Stage 3-2)');
                    }

                    if (currentStage === 'stage2' && stage2Container) {
                        console.log('DEBUG: Hiding stage2Container and attempting to show stage3-2Container immediately.');
                        stage2Container.style.opacity = '0';
                        stage2Container.style.display = 'none'; // Hide immediately
                        
                        // Temporarily bypass transitionend for debugging
                        // stage2Container.addEventListener('transitionend', function onFadeOut() {
                        //     stage2Container.style.display = 'none';
                        //     stage2Container.removeEventListener('transitionend', onFadeOut);

                        if (window.floorplanRenderer && typeof window.floorplanRenderer.stopAnimation === 'function') {
                            console.log('DEBUG: Stopping floorplanRenderer animation.');
                            window.floorplanRenderer.stopAnimation();
                        }

                        if (stage3_2Container && knifeScanVideo) {
                                stage3_2Container.style.display = 'flex'; // Or 'block' if flex not needed by children directly
                                // The flex layout (column, align, justify) is now handled by the container's inline style or CSS class
                                requestAnimationFrame(() => {
                                    stage3_2Container.style.opacity = '1';
                                });
                                currentStage = 'stage3-2';

                                console.log('Setting knifeScanVideo.src to: assets/videos/knife_scan.mp4');
                                knifeScanVideo.src = 'assets/videos/knife_scan.mp4';

                                // --- DEBUGGING VIDEO EVENTS ---
                                knifeScanVideo.oncanplay = () => console.log('DEBUG: knifeScanVideo event: canplay');
                                knifeScanVideo.oncanplaythrough = () => console.log('DEBUG: knifeScanVideo event: canplaythrough');
                                knifeScanVideo.onloadeddata = () => console.log('DEBUG: knifeScanVideo event: loadeddata');
                                knifeScanVideo.onloadedmetadata = () => console.log('DEBUG: knifeScanVideo event: loadedmetadata');
                                knifeScanVideo.onplaying = () => console.log('DEBUG: knifeScanVideo event: playing');
                                knifeScanVideo.onerror = (e) => {
                                    console.error('DEBUG: knifeScanVideo event: error', e);
                                    if (knifeScanVideo.error) {
                                        console.error('DEBUG: knifeScanVideo error code:', knifeScanVideo.error.code, 'message:', knifeScanVideo.error.message);
                                    }
                                };
                                knifeScanVideo.onstalled = () => console.log('DEBUG: knifeScanVideo event: stalled');
                                knifeScanVideo.onsuspend = () => console.log('DEBUG: knifeScanVideo event: suspend');
                                knifeScanVideo.onwaiting = () => console.log('DEBUG: knifeScanVideo event: waiting');
                                // --- END DEBUGGING VIDEO EVENTS ---

                                console.log('Attempting to play knifeScanVideo...');
                                knifeScanVideo.play().then(() => {
                                    console.log('DEBUG: knifeScanVideo.play() promise resolved (playback likely started)');
                                }).catch(error => {
                                    console.error('DEBUG: knifeScanVideo.play() promise rejected:', error);
                                });

                                audioManager.playSound('scanningSFX'); // Reusing cup's scanning sound
                                audioManager.playSound('knifeScanAudio'); // Assumes 'knifeScanAudio' is loaded

                                knifeScanVideo.onended = () => {
                                    console.log('Knife scan video (knife_scan.mp4) finished.');
                                    knifeScanVideo.style.display = 'none'; // Hide video

                                    // Create and show robot.png
                                    const robotImage = document.getElementById('robot-image-stage3-2');
                                    if (robotImage) {
                                        robotImage.style.display = 'block'; // Or 'flex' if its CSS expects that for layout, 'block' is typical for <img>
                                    } else {
                                        console.error('Robot image element (#robot-image-stage3-2) not found!');
                                    }
                                    
                                    audioManager.playSound('fibreTraceAudio');
                                    currentStage = 'stage3-2-robot-image'; // Update current stage

                                    // Listen for fibreTraceAudio to end
                                    const fibreTraceAudioElement = audioManager.sounds['fibreTraceAudio'].element;
                                    if (fibreTraceAudioElement) {
                                        fibreTraceAudioElement.addEventListener('ended', function onFibreTraceAudioEnded() {
                                            console.log('FibreTraceAudio ended. Waiting 3 seconds to transition to Stage 4-2.');
                                            setTimeout(() => {
                                                transitionToStage4_2();
                                            }, 3000); // 3-second delay
                                            fibreTraceAudioElement.removeEventListener('ended', onFibreTraceAudioEnded); // Clean up listener
                                        }, { once: true });
                                    } else {
                                        console.error('fibreTraceAudio element not found in AudioManager. Cannot set up auto-transition to Stage 4-2.');
                                    }

                                    if (currentEPC) { 
                                        scannedTags.add(currentEPC);
                                        console.log(`Tag ${currentEPC} (knife) processed and recorded after video and robot sequence.`);
                                        currentEPC = null; 
                                    }
                                    console.log('Stage 3-2: Video ended, robot sequence initiated. Waiting for FibreTraceAudio and delay.');
                                };

                                // Ensure knifeScanAudio (knife_scan.mp3) also plays. 
                                // Its end event is no longer primary trigger for this sequence.
                                // The audioManager.playSound('knifeScanAudio') call earlier in this function handles its playback.
                            } else {
                                console.error('Stage 3-2 container or video element not found!');
                                transitionToStage2(); // Fallback
                            }
                        // }, { once: true }); // End of bypassed transitionend
                    } else {
                        console.error('Cannot transition to Stage 3-2 from current stage:', currentStage);
                        // Potentially force hide other stages and show stage 3-2 if needed, or go to a safe stage
                    }
                }


                function transitionToStage3_1() {
                    console.log('Transitioning to Stage 3-1 for Cup Scan');
                    const stage2Container = document.getElementById('stage2-container');
                    const stage3_1Container = document.getElementById('stage3-1-container');
                    const rfidScanVideo = document.getElementById('rfid-scan-video');
                    const rfidScanMessage = document.getElementById('rfid-scan-message');

                    // 1. 发送红色流动光和持续马达震动命令
                    if (esp32Connection && esp32Connection.isConnected()) {
                        esp32Connection.sendCommand('L4'); // 红色流动光 (L4是红色流动，L5是蓝色流动)
                        console.log('发送红色流动光命令: L4');
                        
                        // 添加200ms延迟再发送马达命令
                        setTimeout(() => {
                            esp32Connection.sendCommand('M4'); // 持续马达震动 (M4 = 持续震动)
                            console.log('发送持续马达震动命令: M4');
                        },200);
                    } else {
                        console.warn('ESP32未连接，无法发送红色流动光和马达震动命令');
                    }

                    // 2. Fade out Stage 2 elements
                    if (stage2Container) {
                        stage2Container.style.opacity = '0';
                        if (window.floorplanRenderer && typeof window.floorplanRenderer.stopAnimation === 'function') {
                            window.floorplanRenderer.stopAnimation(); // Stop 3D rendering
                        }
                        // After fade out, hide it to prevent interaction
                        stage2Container.addEventListener('transitionend', function onStage2FadeOut() {
                            stage2Container.style.display = 'none';
                            stage2Container.removeEventListener('transitionend', onStage2FadeOut);
                        }, { once: true });
                    }

                    // 2. Prepare and show Stage 3-1 elements
                    if (stage3_1Container && rfidScanVideo && rfidScanMessage) {
                        // rfidScanMessage.textContent = '证物-cup正在被扫描.'; // Message is now set by rfid_data listener
                        stage3_1Container.style.display = 'flex'; // Use flex for centering (as per new HTML structure)
                        
                        // Ensure display is set before starting opacity transition (critical for some browsers)
                        requestAnimationFrame(() => {
                            stage3_1Container.style.opacity = '1';
                            console.log('DEBUG: rfid-scan-message in transitionToStage3_1 - textContent:', rfidScanMessage.textContent, 'offsetHeight:', rfidScanMessage.offsetHeight); // DEBUG LINE
                            rfidScanVideo.currentTime = 0; // Rewind video to start
                            rfidScanVideo.play().catch(error => {
                                console.error("Video play failed:", error);
                            }); // End of video.play().catch()
                            audioManager.playSound('cupScanAudio');

                            rfidScanVideo.onended = () => {
                                console.log('Cup scan video finished.');
                                rfidScanVideo.style.display = 'none'; // Hide video
                                const wifeImage = document.getElementById('wife-image');
                                if (wifeImage) {
                                    wifeImage.style.display = 'block'; // Show image
                                    wifeImage.classList.add('glitch-image-effect'); // Add glitch effect
                                }
                                audioManager.stopSound('cupScanAudio'); // Stop previous audio
                                audioManager.playSound('victimBioAudio'); // Play new audio
                                
                                // Listen for victimBioAudio ended event
                                const victimBioAudioElement = audioManager.sounds['victimBioAudio'].element;
                                victimBioAudioElement.addEventListener('ended', function onVictimBioAudioEnded() {
                                    console.log('Victim biological audio ended, waiting 2s before transitioning to Stage 4-1');
                                    
                                    // Wait 2 seconds before transitioning to Stage 4-1
                                    setTimeout(() => {
                                        transitionToStage4_1();
                                    }, 2000);
                                    
                                    // Remove the event listener to prevent memory leaks
                                    victimBioAudioElement.removeEventListener('ended', onVictimBioAudioEnded);
                                }, { once: true });
                            };
                        }); // End of requestAnimationFrame callback
                            // Example: Fade out Stage 3-1 after video
                            // setTimeout(() => {
                            //    stage3_1Container.style.opacity = '0';
                            //    stage3_1Container.addEventListener('transitionend', () => stage3_1Container.style.display = 'none', { once: true });
                            // }, 1000); // Delay before fading out
                    } else {
                        console.error('Stage 3-1 elements not found!');
                    }
                }

                // Function to transition to Stage 4-1 (Cup Movement)
                function transitionToStage4_1() {
                    console.log('Transitioning to Stage 4-1 for Cup Movement');
                    const stage3_1Container = document.getElementById('stage3-1-container');
                    const stage4_1Container = document.getElementById('stage4-1-container');
                    const cupMovementVideo = document.getElementById('cup-movement-video');
                    const cupMovementMessage = document.getElementById('cup-movement-message');
                    
                    // 1. 停止马达震动并设置蓝光常亮
                    if (esp32Connection && esp32Connection.isConnected()) {
                        // 先发送LED命令
                        esp32Connection.sendCommand('L2'); // 蓝光常亮
                        console.log('设置蓝光常亮 (L2)');
                        
                        // 添加200ms延迟再发送停止马达命令
                        setTimeout(() => {
                            esp32Connection.sendCommand('M0');  // 停止马达震动
                            console.log('发送停止马达震动命令 (M0)');
                        }, 200);
                    } else {
                        console.warn('ESP32未连接，无法设置LED和马达');
                    }

                    // 1. Fade out Stage 3-1 elements
                    if (stage3_1Container) {
                        stage3_1Container.style.opacity = '0';
                        // After fade out, hide it to prevent interaction
                        stage3_1Container.addEventListener('transitionend', function onStage3_1FadeOut() {
                            stage3_1Container.style.display = 'none';
                            stage3_1Container.removeEventListener('transitionend', onStage3_1FadeOut);
                        }, { once: true });
                    }

                    // 2. Prepare and show Stage 4-1 elements
                    if (stage4_1Container && cupMovementVideo && cupMovementMessage) {
                        stage4_1Container.style.display = 'flex'; // Use flex for centering
                        
                        // Ensure display is set before starting opacity transition
                        requestAnimationFrame(() => {
                            stage4_1Container.style.opacity = '1';
                            cupMovementVideo.currentTime = 0; // Rewind video to start
                            cupMovementVideo.play().catch(error => {
                                console.error("Cup movement video play failed:", error);
                            });
                            // 不播放音频，让视频静音播放

                            // 在视频播放 3 秒后显示倒计时并播放音频
                            setTimeout(() => {
                                const countdownTimer = document.getElementById('countdown-timer');
                                if (countdownTimer) {
                                    countdownTimer.style.display = 'block';
                                    let countdown = 6;
                                    countdownTimer.textContent = countdown;
                                    
                                    // 播放倒计时音频
                                    audioManager.playSound('countdownBeeping');
                                    
                                    // 获取倒计时音频元素
                                    const countdownAudio = audioManager.sounds['countdownBeeping'].element;
                                    
                                    // 监听倒计时音频结束事件
                                    countdownAudio.addEventListener('ended', () => {
                                        console.log('Countdown audio ended, transitioning to stage4-1-1');
                                        // 停止视频循环播放
                                        cupMovementVideo.loop = false;
                                        // 过渡到 stage4-1-1
                                        transitionToStage4_1_1();
                                    }, { once: true });
                                    
                                    // 倒计时定时器
                                    const countdownInterval = setInterval(() => {
                                        countdown--;
                                        if (countdown <= 0) {
                                            clearInterval(countdownInterval);
                                            countdownTimer.style.display = 'none';
                                            // 倒计时结束后的操作（如果需要）
                                        } else {
                                            countdownTimer.textContent = countdown;
                                        }
                                    }, 1000);
                                }
                            }, 3000);

                            cupMovementVideo.onended = () => {
                                console.log('Cup movement video finished.');
                                // Optional: Define what happens after cup movement video ends
                                // For example, transition to another stage or show additional information
                            };
                        }); // End of requestAnimationFrame callback
                    } else {
                        console.error('Stage 4-1 elements not found!');
                    }
                }

                // Function to transition to Stage 4-2 (Knife Movement)
                function transitionToStage4_2() {
                    console.log('Transitioning to Stage 4-2 for Knife Movement');
                    
                    // 发送蓝色常亮和停止马达震动命令
                    if (esp32Connection && esp32Connection.isConnected()) {
                        esp32Connection.sendCommand('L2'); // 蓝色常亮 (L2 = 蓝色常亮)
                        console.log('发送蓝色常亮命令: L2 (Stage 4-2)');
                        
                        // 添加200ms延迟再发送停止马达命令
                        setTimeout(() => {
                            esp32Connection.sendCommand('M0'); // 停止马达震动 (M0 = 停止)
                            console.log('发送停止马达震动命令: M0 (Stage 4-2)');
                        }, 200);
                    } else {
                        console.warn('ESP32未连接，无法发送蓝色常亮和停止马达震动命令 (Stage 4-2)');
                    }
                    // Determine the stage to hide based on where we are coming from.
                    // This needs to be dynamically set or passed if stage flow is complex.
                    // Assuming for now we might come from stage3-2 or a similar point before action sequences.
                    let stageToHideId = '';
                    if (currentStage === 'stage3-2-robot-image') { // A more specific state if needed
                        stageToHideId = 'stage3-2-container';
                    } else if (currentStage === 'stage2') { // Or if a direct scan from stage 2 triggers this
                        stageToHideId = 'stage2-container';
                    } else {
                        // Fallback or determine dynamically. For now, let's assume we need to hide the active message container.
                        const activeMessage = document.querySelector('.stage-message[style*="display: flex"], .stage-message[style*="display: block"]:not(#stage4-2-container)');
                        if (activeMessage) stageToHideId = activeMessage.id;
                    }
                    const stageToHide = stageToHideId ? document.getElementById(stageToHideId) : null;

                    const stage4_2Container = document.getElementById('stage4-2-container');
                    const knifeMovementVideo = document.getElementById('knife-movement-video');
                    // const knifeMovementMessage = document.getElementById('knife-movement-message'); // Message element exists but might not need direct manipulation if static

                    // 1. Fade out previous Stage elements
                    if (stageToHide) {
                        stageToHide.style.opacity = '0';
                        stageToHide.addEventListener('transitionend', function onStageToHideFadeOut() {
                            stageToHide.style.display = 'none';
                            stageToHide.removeEventListener('transitionend', onStageToHideFadeOut);
                        }, { once: true });
                    } else {
                        console.warn('No specific stage to hide was determined for transition to Stage 4-2. Ensure currentStage or flow is correct.');
                    }

                    // 2. Prepare and show Stage 4-2 elements
                    if (stage4_2Container && knifeMovementVideo) {
                        stage4_2Container.style.display = 'flex'; 
                        currentStage = 'stage4-2'; // Update current stage tracker
                        
                        requestAnimationFrame(() => {
                            stage4_2Container.style.opacity = '1';
                            knifeMovementVideo.currentTime = 0; 
                            knifeMovementVideo.loop = true; // Ensure it loops until countdown audio ends
                            knifeMovementVideo.play().catch(error => {
                                console.error("Knife movement video play failed:", error);
                            });
                            // Video is silent initially, sound comes with countdown

                            // After 3 seconds of video, show countdown and play audio
                            setTimeout(() => {
                                const countdownTimer = document.getElementById('countdown-timer-stage4-2');
                                if (countdownTimer) {
                                    countdownTimer.style.display = 'block';
                                    let countdown = 6;
                                    countdownTimer.textContent = countdown;
                                    
                                    audioManager.playSound('countdownBeeping');
                                    const countdownAudio = audioManager.sounds['countdownBeeping'].element;
                                    
                                    countdownAudio.addEventListener('ended', () => {
                                        console.log('Countdown audio ended for Stage 4-2, transitioning to Stage 4-2-1.');
                                        knifeMovementVideo.loop = false; // Stop video loop
                                        transitionToStage4_2_1(); // Transition to the action reproduction stage
                                    }, { once: true });
                                    
                                    const countdownInterval = setInterval(() => {
                                        countdown--;
                                        if (countdown < 0) { // Allow 0 to be displayed, then interval stops
                                            clearInterval(countdownInterval);
                                            // Audio 'ended' event will handle the transition after sound finishes
                                        } else {
                                            countdownTimer.textContent = countdown;
                                        }
                                    }, 1000); // Update every second
                                } else {
                                    console.error('Countdown timer for Stage 4-2 (#countdown-timer-stage4-2) not found!');
                                }
                            }, 3000); // 3 seconds delay for countdown initiation
                        });
                    } else {
                        console.error('Stage 4-2 container or knife movement video not found!');
                    }
                }

                // Function to transition to Stage 4-2-1 (Knife Action Reproduction Prompt)
                function transitionToStage4_2_1() {
                    console.log('Transitioning to Stage 4-2-1 for Knife Action Reproduction');
                    
                    // 发送蓝色流动光和单次马达震动命令
                    if (esp32Connection && esp32Connection.isConnected()) {
                        esp32Connection.sendCommand('L5'); // 蓝色流动光 (L5 = 蓝色流动)
                        console.log('发送蓝色流动光命令: L5 (Stage 4-2-1)');
                        
                        // 添加100ms延迟再发送单次马达震动命令
                        setTimeout(() => {
                            esp32Connection.sendCommand('M'); // 单次马达震动 (M = 单次震动)
                            console.log('发送单次马达震动命令: M (Stage 4-2-1)');
                        }, 100);
                    } else {
                        console.warn('ESP32未连接，无法发送蓝色流动光和马达震动命令 (Stage 4-2-1)');
                    }
                    const stage4_2Container = document.getElementById('stage4-2-container');
                    const stage4_2_1Container = document.getElementById('stage4-2-1-container');
                    const messageElement = document.getElementById('action-reproduction-message-stage4-2-1');

                    // 1. Fade out Stage 4-2 elements
                    if (stage4_2Container) {
                        stage4_2Container.style.opacity = '0';
                        stage4_2Container.addEventListener('transitionend', function onStage4_2FadeOut() {
                            stage4_2Container.style.display = 'none';
                            stage4_2Container.removeEventListener('transitionend', onStage4_2FadeOut);
                        }, { once: true });
                    }

                    // 2. Prepare and show Stage 4-2-1 elements
                    if (stage4_2_1Container && messageElement) {
                        stage4_2_1Container.style.display = 'flex'; 
                        
                        requestAnimationFrame(() => {
                            stage4_2_1Container.style.opacity = '1';
                            currentStage = 'stage4-2-1'; // Update current stage

                            console.log('Showing Stage 4-2-1 message. Will transition to Stage 2 after 10 seconds.');

                            setTimeout(async () => {
                                if (currentStage !== 'stage4-2-1') return;
                                console.log('Stage 4-2-1 (Knife) action reproduction time ended. Checking completion status.');
                                const completionStatus = await markTagAsCompletedOnServer(TAG_NAMES.knife);
                                if (completionStatus.all_completed) {
                                    transitionToStage5();
                                } else {
                                    transitionToStage2(true); // Pass true if Stage 2 expects it
                                }
                            }, 10000); // 10-second delay
                        });
                    } else {
                        console.error('Stage 4-2-1 elements (container or message) not found!');
                        transitionToStage2(); // Fallback
                    }
                }

                // Function to transition to Stage 3-3 (Phone Scan)
                function transitionToStage3_3() {
                    console.log('Transitioning to Stage 3-3 for Phone Scan');
                    const stage2Container = document.getElementById('stage2-container');
                    const stage3_3Container = document.getElementById('stage3-3-container');
                    const phoneScanVideo = document.getElementById('phone-scan-video');
                    const husbandImage = document.getElementById('husband-image');

                    // 发送红色流动光和持续马达震动命令
                    if (esp32Connection && esp32Connection.isConnected()) {
                        esp32Connection.sendCommand('L4'); // 红色流动光 (L4是红色流动)
                        console.log('发送红色流动光命令: L4 (Stage 3-3)');
                        
                        // 添加200ms延迟再发送马达命令
                        setTimeout(() => {
                            esp32Connection.sendCommand('M4'); // 持续马达震动 (M4 = 持续震动)
                            console.log('发送持续马达震动命令: M4 (Stage 3-3)');
                        }, 200);
                    } else {
                        console.warn('ESP32未连接，无法发送红色流动光和马达震动命令 (Stage 3-3)');
                    }

                    if (rfidSocket && rfidSocket.connected) {
                        rfidSocket.emit('stop_rfid_scan');
                        console.log('Requested backend to STOP RFID scan for Stage 3-3.');
                    }

                    if (stage2Container) {
                        stage2Container.style.opacity = '0';
                        stage2Container.addEventListener('transitionend', function onStage2FadeOut() {
                            stage2Container.style.display = 'none';
                            stage2Container.removeEventListener('transitionend', onStage2FadeOut);
                        }, { once: true });
                    }

                    if (stage3_3Container && phoneScanVideo && husbandImage) {
                        stage3_3Container.style.display = 'flex';
                        currentStage = 'stage3-3'; 

                        requestAnimationFrame(() => {
                            stage3_3Container.style.opacity = '1';
                            phoneScanVideo.src = 'assets/videos/phone_scan.mp4';
                            phoneScanVideo.currentTime = 0;
                            phoneScanVideo.play().catch(error => console.error("Phone scan video play failed:", error));
                            audioManager.playSound('phoneScanAudio');
                            audioManager.playSound('scanningSFX'); // Play scanning sound effect as requested

                            phoneScanVideo.onended = () => {
                                console.log('Phone scan video finished.');
                                phoneScanVideo.style.display = 'none'; 
                                husbandImage.style.display = 'block'; 
                                audioManager.playSound('phoneContactAudio');

                                const husbandSound = audioManager.sounds['phoneContactAudio'].element;
                                const transitionToNextOrFallback = () => {
                                    if (currentEPC) {
                                        scannedTags.add(currentEPC);
                                        console.log(`Phone EPC ${currentEPC} added to scannedTags. Total scanned: ${scannedTags.size}`);
                                        currentEPC = null; 
                                    }
                                    transitionToStage4_3();
                                };
                                
                                let fallbackTimeoutId = setTimeout(() => {
                                     if (currentStage === 'stage3-3') {
                                        console.warn('Husband contact audio did not end or event listener failed, transitioning to Stage 4-3 via timeout.');
                                        husbandSound.removeEventListener('ended', onSoundEnd); // Clean up just in case
                                        transitionToNextOrFallback();
                                     }
                                }, 8000); // Slightly longer than typical audio + buffer

                                const onSoundEnd = () => {
                                    clearTimeout(fallbackTimeoutId);
                                    console.log('Husband contact audio ended, transitioning to Stage 4-3.');
                                    transitionToNextOrFallback();
                                };
                                husbandSound.addEventListener('ended', onSoundEnd, { once: true });
                            };
                        });
                    } else {
                        console.error('Stage 3-3 elements (container, video, or image) not found!');
                    }
                }

                // Function to transition to Stage 4-3 (Phone Movement)
function transitionToStage4_3() {
    console.log('Transitioning to Stage 4-3 for Phone Movement');
    
    // 发送蓝色常亮和停止马达震动命令
    if (esp32Connection && esp32Connection.isConnected()) {
        esp32Connection.sendCommand('L2'); // 蓝色常亮 (L2 = 蓝色常亮)
        console.log('发送蓝色常亮命令: L2 (Stage 4-3)');
        
        // 添加200ms延迟再发送停止马达命令
        setTimeout(() => {
            esp32Connection.sendCommand('M0'); // 停止马达震动 (M0 = 停止)
            console.log('发送停止马达震动命令: M0 (Stage 4-3)');
        }, 200);
    } else {
        console.warn('ESP32未连接，无法发送蓝色常亮和停止马达震动命令 (Stage 4-3)');
    }
    const stage3_3Container = document.getElementById('stage3-3-container');
    const stage4_3Container = document.getElementById('stage4-3-container');
    const phoneMovementVideo = document.getElementById('phone-movement-video');
    const countdownTimer = document.getElementById('countdown-timer-stage4-3');

    if (stage3_3Container) {
        stage3_3Container.style.opacity = '0';
        stage3_3Container.addEventListener('transitionend', function onStage3_3FadeOut() {
            stage3_3Container.style.display = 'none';
            stage3_3Container.removeEventListener('transitionend', onStage3_3FadeOut);
        }, { once: true });
    }

    if (stage4_3Container && phoneMovementVideo && countdownTimer) {
        stage4_3Container.style.display = 'flex';
        currentStage = 'stage4-3';

        requestAnimationFrame(() => {
            stage4_3Container.style.opacity = '1';
            phoneMovementVideo.src = 'assets/videos/phone_movement.mp4'; // Ensure src is set
            phoneMovementVideo.currentTime = 0;
            phoneMovementVideo.loop = true;
            phoneMovementVideo.play().catch(error => console.error("Phone movement video play failed:", error));
            
            let countdownInterval; 

            setTimeout(() => {
                if (currentStage !== 'stage4-3') return; 
                countdownTimer.style.display = 'block';
                let countdown = 6;
                countdownTimer.textContent = countdown;
                
                audioManager.playSound('countdownBeeping');
                const countdownAudio = audioManager.sounds['countdownBeeping'].element;
                
                countdownAudio.addEventListener('ended', () => {
                    if (currentStage !== 'stage4-3') return; 
                    console.log('Countdown audio ended for Phone, transitioning to stage4-3-1');
                    clearInterval(countdownInterval); 
                    phoneMovementVideo.loop = false; 
                    transitionToStage4_3_1();
                }, { once: true });

                countdownInterval = setInterval(() => {
                    if (currentStage !== 'stage4-3') {
                        clearInterval(countdownInterval);
                        return;
                    }
                    countdown--;
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                        // Transition is handled by audio 'ended' event
                    } else {
                        countdownTimer.textContent = countdown;
                    }
                }, 1000);
            }, 3000); 
        });
    } else {
        console.error('Stage 4-3 elements (container, video, or countdown) not found!');
    }
}

// Function to transition to Stage 4-3-1 (Phone Action Reproduction Prompt)
function transitionToStage4_3_1() {
    console.log('Transitioning to Stage 4-3-1 for Phone Action Reproduction');
    
    // 发送蓝色流动光和单次马达震动命令
    if (esp32Connection && esp32Connection.isConnected()) {
        esp32Connection.sendCommand('L5'); // 蓝色流动光 (L5 = 蓝色流动)
        console.log('发送蓝色流动光命令: L5 (Stage 4-3-1)');
        
        // 添加200ms延迟再发送单次马达震动命令
        setTimeout(() => {
            esp32Connection.sendCommand('M'); // 单次马达震动 (M = 单次震动)
            console.log('发送单次马达震动命令: M (Stage 4-3-1)');
        }, 200);
    } else {
        console.warn('ESP32未连接，无法发送蓝色流动光和马达震动命令 (Stage 4-3-1)');
    }
    const stage4_3Container = document.getElementById('stage4-3-container');
    const stage4_3_1Container = document.getElementById('stage4-3-1-container');

    if (stage4_3Container) {
        stage4_3Container.style.opacity = '0';
        stage4_3Container.addEventListener('transitionend', function onStage4_3FadeOut() {
            stage4_3Container.style.display = 'none';
            stage4_3Container.removeEventListener('transitionend', onStage4_3FadeOut);
        }, { once: true });
    }

    if (stage4_3_1Container) {
        stage4_3_1Container.style.display = 'flex';
        currentStage = 'stage4-3-1';
        
        requestAnimationFrame(() => {
            stage4_3_1Container.style.opacity = '1';
            console.log('Showing Stage 4-3-1 message. Will transition to Stage 2 after 10 seconds.');
            
            if (currentEPC) { // Marking phone as scanned
                scannedTags.add(currentEPC);
                console.log(`Tag ${currentEPC} (phone) has completed its flow and is now permanently marked as scanned.`);
                console.log('Currently scanned tags:', Array.from(scannedTags));
                currentEPC = null; 
            }

            setTimeout(async () => {
                if (currentStage !== 'stage4-3-1') return;
                console.log('Stage 4-3-1 (Phone) action reproduction time ended. Checking completion status.');
                const completionStatus = await markTagAsCompletedOnServer(TAG_NAMES.phone);
                if (completionStatus.all_completed) {
                    transitionToStage5();
                } else {
                    transitionToStage2(true);
                }
            }, 10000); 
        });
    } else {
        console.error('Stage 4-3-1 container not found!');
        transitionToStage2(true); 
    }
}

// Function to transition to Stage 4-1-1 (Action Reproduction Prompt for Cup)
function transitionToStage4_1_1() {
    console.log('Entering transitionToStage4_1_1. currentEPC is:', currentEPC);
    console.log('Transitioning to Stage 4-1-1 for Action Reproduction');
    const stage4_1Container = document.getElementById('stage4-1-container');
    const stage4_1_1Container = document.getElementById('stage4-1-1-container');
    
    // 设置蓝光流动并触发单次马达震动
    if (esp32Connection && esp32Connection.isConnected()) {
        esp32Connection.sendCommand('L5'); // 蓝光流动
        console.log('设置蓝光流动 (L5)');
        
        // 添加100ms延迟再发送马达命令
        setTimeout(() => {
            esp32Connection.sendCommand('M'); // 单次马达震动
            console.log('发送单次马达震动命令: M');
        }, 100);
    } else {
        console.warn('ESP32未连接，无法设置LED和马达');
    }

    if (stage4_1Container) {
        stage4_1Container.style.opacity = '0';
        stage4_1Container.addEventListener('transitionend', function onStage4_1FadeOut() {
            stage4_1Container.style.display = 'none';
            stage4_1Container.removeEventListener('transitionend', onStage4_1FadeOut);
        }, { once: true });
    }

    if (stage4_1_1Container) {
        stage4_1_1Container.style.display = 'flex'; 
        
        requestAnimationFrame(() => {
            stage4_1_1Container.style.opacity = '1';
            currentStage = 'stage4-1-1'; 

            if (currentEPC) {
                scannedTags.add(currentEPC);
                console.log(`Tag ${currentEPC} (cup) has completed its flow and is now permanently marked as scanned.`);
                console.log('Currently scanned tags:', Array.from(scannedTags));
                currentEPC = null; 
            }
            
            setTimeout(async () => {
                if (currentStage !== 'stage4-1-1') return;
                console.log('Stage 4-1-1 (Cup) action reproduction time ended. Checking completion status.');
                const completionStatus = await markTagAsCompletedOnServer(TAG_NAMES.cup);
                if (completionStatus.all_completed) {
                    transitionToStage5();
                } else {
                    transitionToStage2(true);
                }
            }, 3000); 
        });
    } else {
        console.error('Stage 4-1-1 container not found!');
        transitionToStage2(true); 
    }
}

            // Function to transition to Stage 3-4 (Monitor Scan)
            function transitionToStage3_4() {
                console.log('Transitioning to Stage 3-4 for Monitor Scan');
                hideAllStages();
                currentStage = 'stage3-4';

                // 发送红色流动光和持续马达震动命令
                if (esp32Connection && esp32Connection.isConnected()) {
                    esp32Connection.sendCommand('L4'); // 红色流动光 (L4是红色流动)
                    console.log('发送红色流动光命令: L4 (Stage 3-4)');
                    
                    // 添加200ms延迟再发送马达命令
                    setTimeout(() => {
                        esp32Connection.sendCommand('M4'); // 持续马达震动 (M4 = 持续震动)
                        console.log('发送持续马达震动命令: M4 (Stage 3-4)');
                    }, 200);
                } else {
                    console.warn('ESP32未连接，无法发送红色流动光和马达震动命令 (Stage 3-4)');
                }

                const monitorScanMessageEl = document.getElementById('monitor-scan-message');
                if (monitorScanMessageEl) {
                    monitorScanMessageEl.textContent = ''; // Force empty text
                }

                const stage3_4Container = document.getElementById('stage3-4-container');
                const monitorScanVideo = document.getElementById('monitor-scan-video');
                // const monitorScanMessage = document.getElementById('monitor-scan-message'); // Already handled by RFID data

                if (stage3_4Container && monitorScanVideo) {
                    stage3_4Container.style.display = 'flex';
                    requestAnimationFrame(() => {
                        stage3_4Container.style.opacity = '1';
                        monitorScanVideo.currentTime = 0;
                        monitorScanVideo.play().catch(error => console.error("Monitor scan video play failed:", error));
                        audioManager.playSound('monitorScanVoice');
                        audioManager.playSound('scanningSFX'); // Shared scanning sound

                        monitorScanVideo.onended = () => {
                            console.log('Monitor scan video finished.');
                            monitorScanVideo.style.display = 'none';
                            const monitorSceneImage = document.getElementById('monitor-scene-image');
                            if (monitorSceneImage) {
                                monitorSceneImage.style.display = 'block'; // Glitch effect is already on the class
                            }
                            audioManager.stopSound('monitorScanVoice');
                            audioManager.stopSound('scanningSFX');
                            audioManager.playSound('monitorSceneVoice');
                            
                            const monitorSceneVoiceElement = audioManager.sounds['monitorSceneVoice'].element;
                            monitorSceneVoiceElement.addEventListener('ended', function onMonitorSceneVoiceEnded() {
                                console.log('Monitor scene voice ended, waiting 2s before transitioning to Stage 4-4');
                                setTimeout(() => {
                                    transitionToStage4_4();
                                }, 2000);
                                monitorSceneVoiceElement.removeEventListener('ended', onMonitorSceneVoiceEnded);
                            }, { once: true });
                        };
                    });
                } else {
                    console.error('Stage 3-4 elements not found!');
                }
            }

            // Function to transition to Stage 4-4 (Monitor Movement)
            function transitionToStage4_4() {
                console.log('Transitioning to Stage 4-4 for Monitor Movement');
                hideAllStages();
                currentStage = 'stage4-4';
                
                // 发送蓝色常亮和停止马达震动命令
                if (esp32Connection && esp32Connection.isConnected()) {
                    esp32Connection.sendCommand('L2'); // 蓝色常亮 (L2 = 蓝色常亮)
                    console.log('发送蓝色常亮命令: L2 (Stage 4-4)');
                    
                    // 添加200ms延迟再发送停止马达命令
                    setTimeout(() => {
                        esp32Connection.sendCommand('M0'); // 停止马达震动 (M0 = 停止)
                        console.log('发送停止马达震动命令: M0 (Stage 4-4)');
                    }, 200);
                } else {
                    console.warn('ESP32未连接，无法发送蓝色常亮和停止马达震动命令 (Stage 4-4)');
                }
                const stage4_4Container = document.getElementById('stage4-4-container');
                const monitorMovementVideo = document.getElementById('monitor-movement-video');

                if (stage4_4Container && monitorMovementVideo) {
                    stage4_4Container.style.display = 'flex';
                    requestAnimationFrame(() => {
                        stage4_4Container.style.opacity = '1';
                        monitorMovementVideo.currentTime = 0;
                        monitorMovementVideo.play().catch(error => console.error("Monitor movement video play failed:", error));
                        
                        setTimeout(() => {
                            const countdownTimer = document.getElementById('countdown-timer-stage4-4');
                            if (countdownTimer) {
                                countdownTimer.style.display = 'block';
                                let countdown = 6;
                                countdownTimer.textContent = countdown;
                                audioManager.playSound('countdownBeeping');
                                const countdownAudio = audioManager.sounds['countdownBeeping'].element;
                                countdownAudio.addEventListener('ended', () => {
                                    console.log('Countdown audio ended for Monitor, transitioning to stage4-4-1');
                                    monitorMovementVideo.loop = false;
                                    transitionToStage4_4_1();
                                }, { once: true });
                                
                                const countdownInterval = setInterval(() => {
                                    countdown--;
                                    if (countdown <= 0) {
                                        clearInterval(countdownInterval);
                                        countdownTimer.style.display = 'none';
                                    } else {
                                        countdownTimer.textContent = countdown;
                                    }
                                }, 1000);
                            }
                        }, 3000); // 3-second delay before countdown starts

                        monitorMovementVideo.onended = () => {
                            console.log('Monitor movement video finished (if not looped and countdown logic completes first).');
                        };
                    });
                } else {
                    console.error('Stage 4-4 elements not found!');
                }
            }

            // Function to transition to Stage 4-4-1 (Monitor Action Reproduction Prompt)
            function transitionToStage4_4_1() {
                console.log('Transitioning to Stage 4-4-1 for Monitor Action Prompt');
                hideAllStages();
                currentStage = 'stage4-4-1';
                
                // 发送蓝色流动光和单次马达震动命令
                if (esp32Connection && esp32Connection.isConnected()) {
                    esp32Connection.sendCommand('L5'); // 蓝色流动光 (L5 = 蓝色流动)
                    console.log('发送蓝色流动光命令: L5 (Stage 4-4-1)');
                    
                    // 添加200ms延迟再发送单次马达震动命令
                    setTimeout(() => {
                        esp32Connection.sendCommand('M'); // 单次马达震动 (M = 单次震动)
                        console.log('发送单次马达震动命令: M (Stage 4-4-1)');
                    }, 200);
                } else {
                    console.warn('ESP32未连接，无法发送蓝色流动光和马达震动命令 (Stage 4-4-1)');
                }
                const stage4_4_1Container = document.getElementById('stage4-4-1-container');

                if (stage4_4_1Container) {
                    stage4_4_1Container.style.display = 'flex';
                    requestAnimationFrame(() => {
                        stage4_4_1Container.style.opacity = '1';
                        if (currentEPC) {
                           scannedTags.add(currentEPC);
                           console.log(`Tag ${currentEPC} (monitor) processed and recorded.`);
                           currentEPC = null; 
                        }
                        setTimeout(async () => {
                            if (currentStage !== 'stage4-4-1') return;
                            console.log('Stage 4-4-1 (Monitor) action reproduction time ended. Checking completion status.');
                            const completionStatus = await markTagAsCompletedOnServer(TAG_NAMES.monitor);
                            if (completionStatus.all_completed) {
                                transitionToStage5();
                            } else {
                                transitionToStage2(true);
                            }
                        }, 3000); // 3-second delay
                    });
                } else {
                    console.error('Stage 4-4-1 elements not found!');
                }
            }
        }); // Closes DOMContentLoaded
        </script>
    </body>
</html>
